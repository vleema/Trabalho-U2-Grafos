\chapter{Implementação}
\label{ch:implementation}

Nesse capítulo serão mostradas as implementações reais de cada algoritmo, acrescidas de comentários que elucidem as escolhas de implementações tomadas. 

\section{Algoritmos de Árvore Geradora Mínima}
\section{Algoritmos de Caminho Mais Curto}
\subsection{Algoritmo de Dijkstra}
Para a implementação de Dijkstra foi elaborado a seguinte \textit{struct}:
\begin{lstlisting}[language=Rust, caption={Resultado de Dijkstra}]
pub struct DijkstraResult<Node, Weight> {
    pub route: HashMap<Node, (Weight, Option<Node>)>,
}
\end{lstlisting}

Esta estrutura é responsável por armazenar um dicionário que contém o resultado do Algortimo de Dijkstra, onde cada chave é um nó que aponta para uma dupla, que indica o predecessor até o nó e também a distância dele da origem.

\begin{lstlisting}[language=Rust, caption={Implementação do Algoritmo de Dijkstra}]
impl<N: Node, W: Weight> DijkstraResult<N, W> {
    pub fn new(graph: &(impl WeightedGraph<N, W> + ?Sized), start: N) -> Self {
        let mut route: HashMap<N, (W, Option<N>)> = HashMap::new();
        let mut visited: HashSet<N> = HashSet::new();
        let mut distance: HashMap<N, W> = HashMap::new();
        let mut pred: HashMap<N, Option<N>> = HashMap::new();
        distance.insert(start, W::zero());
        pred.insert(start, None);

        for (neighbor, weight) in graph.weighted_neighbors(start) {
            pred.insert(neighbor, Some(start));
            distance.insert(neighbor, weight);
        }

        loop {
            let mut unvisited_node: Option<(N, W)> = None;
            for node in graph.nodes() {
                if !visited.contains(&node)
                    && let Some(distance) = distance.get(&node)
                    && (unvisited_node.is_none()
                        || (unvisited_node.is_some() && distance < &unvisited_node.unwrap().1))
                {
                    unvisited_node = Some((node, *distance));
                }
            }

            match unvisited_node {
                None => break,
                Some((node, node_weight)) => {
                    visited.insert(node);

                    for (neighbor, weight) in graph.weighted_neighbors(node) {
                        if !visited.contains(&neighbor) {
                            let new_distance = weight + node_weight;

                            match distance.get(&neighbor) {
                                Some(&neighbor_distance) => {
                                    if neighbor_distance > new_distance {
                                        distance.insert(neighbor, new_distance);
                                        pred.insert(neighbor, Some(node));
                                    }
                                }
                                None => {
                                    distance.insert(neighbor, new_distance);
                                    pred.insert(neighbor, Some(node));
                                }
                            }
                        }
                    }

                    let mut parent: Option<N> = None;
                    if let Some(opt) = pred.get(&node) {
                        parent = *opt;
                    }

                    route.insert(node, (node_weight, parent));
                }
            }
        }
        Self { route }
    }
}
\end{lstlisting}

A função \textit{new} é responsável por executar o Algoritmo de Dijkstra e retornar seu resultado. Para manter o controle de vértices visitados, a distância até eles e também seus predecessores, criamos dicionários e conjuntos auxiliares para este processo. 

O algoritmo inicia definindo a distância e o predecessor do nó inicial como 0 e \textit{None}, respectivamente, para então definir os mesmos elementos para os seus vizinhos, mas sem marcar ninguém como visitado. Após isso, inicia-se o loop principal: a cada iteração, é buscado o vértice com menor distância, para que este seja visitado e os seus vizinhos sejam relaxados, ou seja, tenham sua distância e predecessor atualizados caso seja vantajoso; ao visitar um vértice, note que ele é salvo no dicionário \texttt{route}, onde o vértice é a chave que aponta para a dupla com a sua distância e também seu predecessor. Ao acabar os nós não visitados, a função retorna a rota completa.

Para encontrar, então, o caminho entre dois vértices, o consumidor da função pode acessar o dicionário \texttt{route} a partir do vértice final e ir explorando seus predecessores até encontrar o nó inicial. Isso traz solidez e isolamento para o algoritmo, que é capaz de cumprir com eficácia seu objetivo principal sem se preocupar com o modo em que as informações serão usadas.

\section{Algoritmos de Grafos Eulerianos}
